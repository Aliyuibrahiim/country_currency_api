const express = require('express');
const mysql = require('mysql2/promise');
const axios = require('axios');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

const app = express();
app.use(express.json());
app.use(cors());

// Database configuration
const dbConfig = {
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    port: 3306,
    acquireTimeout: 60000,
    connectTimeout: 60000,
    timeout: 60000,
    reconnect: true,
    connectionLimit: 10
};

const pool = mysql.createPool(dbConfig);
let lastRefreshTime = null;

// Ensure cache directory exists
const cacheDir = path.join(__dirname, 'cache');
if (!fs.existsSync(cacheDir)) {
    fs.mkdirSync(cacheDir, { recursive: true });
}

// Helper functions
async function getConnection() {
    return await pool.getConnection();
}

function getRandomNumber(min, max) {
    return Math.random() * (max - min) + min;
}

// Simple HTML-based image generation
async function generateSummaryImage() {
    let connection;
    try {
        connection = await getConnection();
        
        // Get total countries
        const [[{ total_countries }]] = await connection.execute(
            'SELECT COUNT(*) as total_countries FROM countries'
        );
        
        // Get top 5 countries by GDP
        const [topCountries] = await connection.execute(
            'SELECT name, estimated_gdp FROM countries WHERE estimated_gdp IS NOT NULL ORDER BY estimated_gdp DESC LIMIT 5'
        );
        
        // Get last refresh time
        const [[{ last_refreshed_at }]] = await connection.execute(
            'SELECT MAX(last_refreshed_at) as last_refreshed_at FROM countries'
        );

        // Create simple HTML representation (we'll serve this as the "image")
        const refreshTime = last_refreshed_at ? new Date(last_refreshed_at).toLocaleString() : 'Never';
        
        const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <title>Country Currency API Summary</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #1a1a2e; color: white; }
        .container { max-width: 800px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 30px; }
        .stats { background: #2a2a4e; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .country-list { background: #2a2a4e; padding: 20px; border-radius: 10px; }
        .country-item { margin: 10px 0; padding: 10px; background: #3a3a5e; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Country Currency API Summary</h1>
        </div>
        
        <div class="stats">
            <h2>Total Countries: ${total_countries}</h2>
            <h2>Last Refresh: ${refreshTime}</h2>
        </div>
        
        <div class="country-list">
            <h2>Top 5 Countries by GDP</h2>
            ${topCountries.map((country, index) => `
                <div class="country-item">
                    <strong>${index + 1}. ${country.name}</strong>: 
                    $${country.estimated_gdp ? country.estimated_gdp.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}
                </div>
            `).join('')}
        </div>
        
        <div style="text-align: center; margin-top: 30px; color: #cccccc;">
            Generated by Country Currency API
        </div>
    </div>
</body>
</html>
        `;

        // Save HTML content
        const htmlPath = path.join(cacheDir, 'summary.html');
        fs.writeFileSync(htmlPath, htmlContent);
        
        console.log('Summary HTML generated successfully');
        return true;
        
    } catch (error) {
        console.error('Error generating summary:', error);
        return false;
    } finally {
        if (connection) connection.release();
    }
}

// 1. POST /countries/refresh - Fetch and cache countries + generate summary
app.post('/countries/refresh', async (req, res) => {
    let connection;
    try {
        connection = await getConnection();
        
        console.log('Fetching countries data...');
        const countriesResponse = await axios.get(
            'https://restcountries.com/v2/all?fields=name,capital,region,population,flag,currencies',
            { timeout: 30000 }
        );
        
        console.log('Fetching exchange rates...');
        const exchangeResponse = await axios.get(
            'https://open.er-api.com/v6/latest/USD',
            { timeout: 30000 }
        );
        const exchangeRates = exchangeResponse.data.rates;
        
        const countries = countriesResponse.data;
        let processedCount = 0;
        let successCount = 0;
        
        console.log(`Processing ${countries.length} countries...`);
        
        for (const country of countries.slice(0, 50)) { // Process only 50 for testing
            try {
                let currencyCode = null;
                let exchangeRate = null;
                let estimatedGDP = null;
                
                // Get first currency if available
                if (country.currencies && country.currencies.length > 0 && country.currencies[0].code) {
                    currencyCode = country.currencies[0].code;
                    
                    if (currencyCode && exchangeRates[currencyCode]) {
                        exchangeRate = exchangeRates[currencyCode];
                        const randomMultiplier = getRandomNumber(1000, 2000);
                        estimatedGDP = (country.population * randomMultiplier) / exchangeRate;
                    }
                }
                
                // Check if country exists
                const [existing] = await connection.execute(
                    'SELECT id FROM countries WHERE LOWER(name) = LOWER(?)',
                    [country.name]
                );
                
                if (existing.length > 0) {
                    // Update existing country
                    await connection.execute(
                        `UPDATE countries SET 
                         capital = ?, region = ?, population = ?, currency_code = ?, 
                         exchange_rate = ?, estimated_gdp = ?, flag_url = ?, last_refreshed_at = NOW() 
                         WHERE LOWER(name) = LOWER(?)`,
                        [
                            country.capital || null,
                            country.region || null,
                            country.population,
                            currencyCode,
                            exchangeRate,
                            estimatedGDP,
                            country.flag || null,
                            country.name
                        ]
                    );
                } else {
                    // Insert new country
                    await connection.execute(
                        `INSERT INTO countries 
                         (name, capital, region, population, currency_code, exchange_rate, estimated_gdp, flag_url) 
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
                        [
                            country.name,
                            country.capital || null,
                            country.region || null,
                            country.population,
                            currencyCode,
                            exchangeRate,
                            estimatedGDP,
                            country.flag || null
                        ]
                    );
                }
                
                successCount++;
                processedCount++;
                
            } catch (countryError) {
                console.error(`Error processing ${country.name}:`, countryError.message);
                processedCount++;
                continue;
            }
        }
        
        lastRefreshTime = new Date().toISOString();
        
        // Generate summary after refresh
        console.log('Generating summary...');
        await generateSummaryImage();
        
        res.json({
            message: `Successfully refreshed ${successCount} out of ${processedCount} countries`,
            total_countries: successCount,
            last_refreshed_at: lastRefreshTime,
            summary_generated: true
        });
        
    } catch (error) {
        console.error('Refresh failed:', error);
        
        if (error.response) {
            return res.status(503).json({
                error: 'External data source unavailable',
                details: `Could not fetch data from external API: ${error.message}`
            });
        }
        
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        if (connection) connection.release();
    }
});

// 2. GET /countries - Get all countries with filtering and sorting
app.get('/countries', async (req, res) => {
    let connection;
    try {
        const { region, currency, sort } = req.query;
        
        connection = await getConnection();
        
        let query = 'SELECT * FROM countries WHERE 1=1';
        const params = [];
        
        if (region) {
            query += ' AND LOWER(region) = LOWER(?)';
            params.push(region);
        }
        
        if (currency) {
            query += ' AND currency_code = ?';
            params.push(currency.toUpperCase());
        }
        
        // Sorting
        if (sort === 'gdp_desc') {
            query += ' ORDER BY estimated_gdp DESC';
        } else if (sort === 'gdp_asc') {
            query += ' ORDER BY estimated_gdp ASC';
        } else if (sort === 'population_desc') {
            query += ' ORDER BY population DESC';
        } else if (sort === 'population_asc') {
            query += ' ORDER BY population ASC';
        } else {
            query += ' ORDER BY name ASC';
        }
        
        const [countries] = await connection.execute(query, params);
        
        res.json(countries);
        
    } catch (error) {
        console.error('Error fetching countries:', error);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        if (connection) connection.release();
    }
});

// 3. GET /countries/:name - Get one country by name
app.get('/countries/:name', async (req, res) => {
    let connection;
    try {
        const countryName = req.params.name;
        
        connection = await getConnection();
        
        const [countries] = await connection.execute(
            'SELECT * FROM countries WHERE LOWER(name) = LOWER(?)',
            [countryName]
        );
        
        if (countries.length === 0) {
            return res.status(404).json({ error: 'Country not found' });
        }
        
        res.json(countries[0]);
        
    } catch (error) {
        console.error('Error fetching country:', error);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        if (connection) connection.release();
    }
});

// 4. DELETE /countries/:name - Delete a country record
app.delete('/countries/:name', async (req, res) => {
    let connection;
    try {
        const countryName = req.params.name;
        
        connection = await getConnection();
        
        const [result] = await connection.execute(
            'DELETE FROM countries WHERE LOWER(name) = LOWER(?)',
            [countryName]
        );
        
        if (result.affectedRows === 0) {
            return res.status(404).json({ error: 'Country not found' });
        }
        
        // Regenerate summary after deletion
        await generateSummaryImage();
        
        res.status(204).send();
        
    } catch (error) {
        console.error('Error deleting country:', error);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        if (connection) connection.release();
    }
});

// 5. GET /status - Show total countries and last refresh timestamp
app.get('/status', async (req, res) => {
    let connection;
    try {
        connection = await getConnection();
        
        const [[{ total_countries }]] = await connection.execute(
            'SELECT COUNT(*) as total_countries FROM countries'
        );
        
        const [[{ last_refreshed_at }]] = await connection.execute(
            'SELECT MAX(last_refreshed_at) as last_refreshed_at FROM countries'
        );
        
        res.json({
            total_countries,
            last_refreshed_at: last_refreshed_at || lastRefreshTime
        });
        
    } catch (error) {
        console.error('Error fetching status:', error);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        if (connection) connection.release();
    }
});

// 6. GET /countries/image - Serve summary as HTML
app.get('/countries/image', (req, res) => {
    const htmlPath = path.join(cacheDir, 'summary.html');
    
    if (!fs.existsSync(htmlPath)) {
        return res.status(404).json({ error: 'Summary not found' });
    }
    
    res.setHeader('Content-Type', 'text/html');
    res.sendFile(htmlPath);
});

// Health check endpoint
app.get('/', (req, res) => {
    res.json({ 
        message: 'Country Currency API is running!',
        endpoints: {
            'POST /countries/refresh': 'Fetch and cache countries + generate summary',
            'GET /countries': 'Get all countries with filters',
            'GET /countries/:name': 'Get specific country',
            'DELETE /countries/:name': 'Delete country',
            'GET /status': 'Get API status',
            'GET /countries/image': 'Get summary (HTML)'
        }
    });
});

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`ðŸš€ Server running on port ${PORT}`);
});

module.exports = app;